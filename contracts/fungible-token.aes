// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

contract FungibleToken =

  type balance = map(address, int)

  // allowance from account, for account, with amount
  type allowance = map((address, address), int)

  record state =
    { owner        : address
    , name         : string
    , symbol       : string
    , total_supply : int
    , decimals     : int
    , balances     : balance
    , allowances   : allowance }

  datatype event =
    Transfer(indexed address, indexed address, indexed int)
    | Approval(indexed address, indexed address, indexed int)

  public stateful function init(name: string, total_supply : int, decimals : int, symbol : string) =
    { owner        = Call.caller,
      name         = name,
      symbol       = symbol,
      total_supply = total_supply,
      decimals     = decimals,
      balances     = {},
      allowances   = {} }

  public function name() : string =
    state.name

  public function symbol() : string =
    state.symbol

  public function decimals() : int =
    state.decimals

  public stateful function transfer(to: address, value: int) =
    internal_transfer(Call.caller, to, value)
    Chain.event(Transfer(Call.caller, to, value))

  public stateful function approve(spender: address, value: int) =
    require(value >= 0, "The provided value cannot be sub zero.")
    put(state{ allowances[(Call.caller, spender)] = value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public function total_supply() : int =
    state.total_supply

  public function owner() : address =
    state.owner

  public function balances() : balance =
    state.balances

  public function allowances() : allowance =
    state.allowances

  public function balance_of(owner: address) : int =
    Map.lookup_default(owner, state.balances, 0)

  public function allowance(owner: address, spender: address) : int =
    Map.lookup_default((owner, spender), state.allowances, 0)

  public function allowance_from(addr: address) : int =
    Map.lookup_default((addr, Call.caller), state.allowances, 0)

  public stateful function transfer_from(from: address, to: address, value: int) =
    require(allowance_from(from) >= value, "The provided value is larger than what is allowances.")
    put(state{ allowances[(from, Call.caller)] = allowance_from(from) - value })
    internal_transfer(from, to, value)
    Chain.event(Transfer(from, to, value))

  public stateful function increase_allowance(spender: address, added_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] + added_value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public stateful function decrease_allowance(spender: address, subtracted_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] - subtracted_value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public stateful function mint(account: address, value: int) =
    only_owner()
    put(state{ total_supply = state.total_supply + value, balances[account] = balance_of(account) + value })

  public stateful function burn(value: int) =
    require(balance_of(Call.caller) >= value, "The value provided for burning is less than account's balance.")
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] = balance_of(Call.caller) - value })

  // INTERNAL FUNCTIONS

  private function only_owner() =
    require(Call.caller == state.owner, "Only owner can mint new tokens!")

  private stateful function internal_transfer(from: address, to: address, value: int) =
    require(value >= 0, "The provided value cannot be sub zero")
    require(value < balance_of(from), "Not enough balance.")
    put(state{ balances[from] = balance_of(from) - value, balances[to] = balance_of(to) + value })

  // GENERIC HELPER FUNCTIONS

  private function require(expression : bool, error : string) =
    if(!expression)
      abort(error)
