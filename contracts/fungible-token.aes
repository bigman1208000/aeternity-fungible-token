// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

contract FungibleToken =

  type balance = map(address, int)

  // allowance from account, for account, with amount
  type allowance = map((address, address), int)

  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  record state =
    { owner        : address
    , total_supply : int
    , balances     : balance
    , allowances   : allowance
    , meta_info    : meta_info }

  datatype event =
    Transfer(indexed address, indexed address, indexed int)
    | Allowance(indexed address, indexed address, indexed int)
    | Burn(indexed address, indexed int)

  public stateful function init(name: string, total_supply : int, decimals : int, symbol : string) =
    { owner        = Call.caller,
      total_supply = total_supply,
      balances     = {},
      allowances   = {},
      meta_info    = { name = name, symbol = symbol, decimals = decimals } }

  public function meta_info() : meta_info =
    state.meta_info

  public stateful function transfer(to: address, value: int) =
    internal_transfer(Call.caller, to, value)
    Chain.event(Transfer(Call.caller, to, value))

  public stateful function approve(spender: address, value: int) =
    require(value >= 0, "INVALID_VALUE_SUB_ZERO")
    put(state{ allowances[(Call.caller, spender)] = value })
    Chain.event(Allowance(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public function total_supply() : int =
    state.total_supply

  public function owner() : address =
    state.owner

  public function balances() : balance =
    state.balances

  public function allowances() : allowance =
    state.allowances

  public function balance_of(owner: address) : int =
    Map.lookup_default(owner, state.balances, 0)

  public function allowance(owner: address, spender: address) : int =
    Map.lookup_default((owner, spender), state.allowances, 0)

  public function allowance_from(addr: address) : int =
    Map.lookup_default((addr, Call.caller), state.allowances, 0)

  public stateful function transfer_from(from: address, to: address, value: int) =
    require(allowance_from(from) >= value, "INSUFFICIENT_ALLOWANCE")
    put(state{ allowances[(from, Call.caller)] = allowance_from(from) - value })
    internal_transfer(from, to, value)
    Chain.event(Transfer(from, to, value))

  public stateful function increase_allowance(spender: address, added_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] + added_value })
    Chain.event(Allowance(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public stateful function decrease_allowance(spender: address, subtracted_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] - subtracted_value })
    Chain.event(Allowance(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public stateful function mint(account: address, value: int) =
    only_owner()
    put(state{ total_supply = state.total_supply + value, balances[account] = balance_of(account) + value })

  public stateful function burn(value: int) =
    require(balance_of(Call.caller) >= value, "INSUFFICIENT_BALANCE")
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] = balance_of(Call.caller) - value })
    Chain.event(Burn(Call.caller, value))

  // INTERNAL FUNCTIONS

  private function only_owner() =
    require(Call.caller == state.owner, "INVALID_CALL_CONTRACT_OWNER")

  private stateful function internal_transfer(from: address, to: address, value: int) =
    require(value >= 0, "INVALID_VALUE_SUB_ZERO")
    require(value < balance_of(from), "INSUFFICIENT_BALANCE")
    put(state{ balances[from] = balance_of(from) - value, balances[to] = balance_of(to) + value })

  // GENERIC HELPER FUNCTIONS

  private function require(expression : bool, error : string) =
    if(!expression)
      abort(error)
