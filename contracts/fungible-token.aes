// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

contract FungibleToken =

  type balances = map(address, int)

  record allowance_accounts = { from_account : address, for_account : address }

  type allowances = map(allowance_accounts, int)

  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  record state =
    { owner        : address
    , total_supply : int
    , balances     : balances
    , allowances   : allowances
    , meta_info    : meta_info }

  datatype event =
    Transfer(indexed address, indexed address, indexed int)
    | Allowance(indexed address, indexed address, indexed int)
    | Burn(indexed address, indexed int)

  public stateful function init(name: string, total_supply : int, decimals : int, symbol : string) =
    { owner        = Call.caller,
      total_supply = total_supply,
      balances     = {},
      allowances   = {},
      meta_info    = { name = name, symbol = symbol, decimals = decimals } }

  public function meta_info() : meta_info =
    state.meta_info

  public function total_supply() : int =
    state.total_supply

  public function owner() : address =
    state.owner

  public function balances() : balances =
    state.balances

  public function allowances() : allowances =
    state.allowances


  public function balance(owner: address) : option(int) =
    Map.lookup(owner, state.balances)

  public function allowance(allowance_accounts : allowance_accounts) : option(int) =
    Map.lookup(allowance_accounts, state.allowances)

  public function allowance_for_caller(from_account: address) : option(int) =
    allowance({ from_account = from_account, for_account = Call.caller })


  public stateful function transfer(to_account: address, value: int) =
    internal_transfer(Call.caller, to_account, value)

  public stateful function transfer_allowance(from_account: address, to_account: address, value: int) =
    let allowance_accounts = { from_account = from_account, for_account = Call.caller }
    internal_change_allowance(allowance_accounts, -value)
    internal_transfer(from_account, to_account, value)

  public stateful function create_allowance(for_account: address, value: int) =
    require_non_negative_value(value)
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    require_allowance_not_existent(allowance_accounts)
    put(state{ allowances[allowance_accounts] = value })
    Chain.event(Allowance(Call.caller, for_account, value))

  public stateful function change_allowance(for_account: address, value_change: int) =
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    internal_change_allowance(allowance_accounts, value_change)


  public stateful function mint(account: address, value: int) =
    require_owner()
    let balance = balance_or_zero(account)
    put(state{ total_supply = state.total_supply + value, balances[account] = balance + value })

  public stateful function burn(value: int) =
    let balance = require_balance(Call.caller, value)
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] = balance - value })

  // INTERNAL FUNCTIONS

  private function balance_or_zero(account : address) : int =
    switch(balance(account))
      Some(balance) => balance
      None => 0

  private function require_owner() =
    require(Call.caller == state.owner, "ONLY_OWNER_CALL_ALLOWED")

  private function require_allowance_existent(allowance_accounts : allowance_accounts) =
    switch(allowance(allowance_accounts))
      None => abort("ALLOWANCE_NOT_EXISTENT")

  private function require_allowance_not_existent(allowance_accounts : allowance_accounts) =
    switch(allowance(allowance_accounts))
      Some(_) => abort("ALLOWANCE_ALREADY_EXISTENT")

  private function require_non_negative_value(value : int) =
    require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

  private function require_allowance(allowance_accounts : allowance_accounts, value : int) : int =
    switch(allowance(allowance_accounts))
      Some(allowance) =>
        require(allowance >= value, "ACCOUNT_INSUFFICIENT_ALLOWANCE")
        allowance
      None => abort("ALLOWANCE_NOT_EXISTENT")

  private function require_balance(account : address, value : int) : int =
    switch(balance(account))
      Some(balance) =>
        require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
        balance
      None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

  private stateful function internal_transfer(from_account: address, to_account: address, value: int) =
    require_non_negative_value(value)
    let balance_from = require_balance(from_account, value)
    let balance_to = balance_or_zero(to_account)
    put(state{ balances[from_account] = balance_from - value, balances[to_account] = balance_to + value })
    Chain.event(Transfer(from_account, to_account, value))

  private stateful function internal_change_allowance(allowance_accounts : allowance_accounts, value_change : int) =
    let allowance = require_allowance(allowance_accounts, value_change)
    let new_allowance = allowance + value_change
    require_non_negative_value(new_allowance)
    put(state{ allowances[allowance_accounts] = new_allowance })
    Chain.event(Allowance(allowance_accounts.from_account, allowance_accounts.for_account, new_allowance))

  // GENERIC HELPER FUNCTIONS

  private function require(expression : bool, error : string) =
    if(!expression)
      abort(error)
